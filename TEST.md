# godot-neovim テスト手順書

## 概要

マルチバッファ設計変更に伴う再テスト対象コマンドのテスト手順と結果を記録する。

## テスト環境

- Godot 4.2以上
- Neovim 0.9以上
- テスト用GDScriptファイル 2-3個

---

## 最高優先度 (P0) - マルチバッファ設計で直接影響

### `:q` - ファイルを閉じる
**状態**: テスト済み

**テスト手順**:
1. ファイルAを開く
2. カーソルを任意の位置に移動（例: 55行目）
3. `:q` で閉じる
4. 同じファイルAを再度開く
5. カーソル位置が復元されることを確認

**期待結果**: カーソル位置が閉じた時の位置に復元される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `gt` / `gT` - タブ切り替え
**状態**: テスト済み

**テスト手順**:
1. ファイルA、ファイルBを開く
2. ファイルAでカーソルを55行目に移動
3. `gt` でファイルBに切り替え
4. ファイルBでカーソルを10行目に移動
5. `gT` でファイルAに戻る
6. カーソルが55行目に復元されることを確認
7. `gt` でファイルBに戻る
8. カーソルが10行目に復元されることを確認

**期待結果**: 各ファイルでカーソル位置が独立して保持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `u` / `Ctrl+R` - Undo/Redo
**状態**: テスト済み

**テスト手順**:
1. ファイルAで `o` で新しい行を追加、テキスト入力、ESC
2. `gt` でファイルBに切り替え
3. ファイルBで `o` で新しい行を追加、テキスト入力、ESC
4. `u` でファイルBの変更をUndo
5. `gT` でファイルAに戻る
6. `u` でファイルAの変更をUndo
7. 各ファイルのUndo履歴が独立していることを確認

**期待結果**: 各バッファのUndo/Redoスタックが独立している

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `Ctrl+O` / `Ctrl+I` - Jump list
**状態**: テスト済み

**テスト手順**:
1. ファイルAを開く
2. `:100` で100行目にジャンプ
3. `:50` で50行目にジャンプ
4. `:10` で10行目にジャンプ
5. `Ctrl+O` で50行目に戻る
6. `Ctrl+O` で100行目に戻る
7. `Ctrl+I` で50行目に進む

**期待結果**: Jump listが正しく機能する

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `ESC` - Insert mode終了
**状態**: テスト済み

**テスト手順**:
1. ファイルAで `i` でInsert modeに入る
2. テキストを入力
3. `ESC` でNormal modeに戻る
4. `u` でUndoできることを確認
5. `gt` でファイルBに切り替え
6. 同様にInsert mode → ESC → Undo を確認

**期待結果**: ESC後にUndo可能、バッファ同期が正しく行われる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

## 高優先度 (P1)

### `:w` - 保存
**状態**: テスト済み

**テスト手順**:
1. ファイルを開いて編集
2. `:w` で保存
3. dirty marker が消えることを確認
4. 別ファイルに切り替えて戻る
5. 保存内容が保持されていることを確認

**期待結果**: ファイルが保存され、dirty flagがクリアされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `:wq` / `ZZ` - 保存して閉じる
**状態**: テスト済み

**テスト手順**:
1. ファイルを編集
2. `:wq` または `ZZ` を実行
3. ファイルが保存されて閉じることを確認
4. 再度開いて変更が保存されていることを確認

**期待結果**: ファイルが保存されて閉じる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `:e` - ファイルを開く
**状態**: テスト済み

**テスト手順**:
1. `:e` でQuick openダイアログを開く
2. ファイルを選択して開く
3. Neovimで `:buffers` を実行してバッファが追加されていることを確認
4. `:e res://path/to/file.gd` で直接ファイルを開く

**期待結果**: ファイルが開かれ、Neovimにバッファが作成される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `:qa` - 全て閉じる
**状態**: テスト済み

**テスト手順**:

#### テスト 1: 保存済みファイル
1. 3つのスクリプトを開く（すべて保存済み）
2. `:qa` を実行
3. **期待**: すべてのタブが閉じる

#### テスト 2: 未保存ファイル
1. 3つのスクリプトを開く
2. 各ファイルを変更して未保存状態にする
3. `:qa` を実行
4. **期待**: 1つ目のファイルでダイアログ → 保存/破棄選択 → 2つ目でも同様...

#### テスト 3: キャンセル動作
1. 3つの未保存ファイルを開く
2. `:qa` を実行
3. 1つ目のダイアログで「キャンセル」（X ボタン）
4. **期待**: 1つ目は開いたまま、2つ目のダイアログが表示される
5. 2つ目で「保存」または「破棄」を選択
6. **期待**: 2つ目が閉じ、3つ目のダイアログが表示される

#### テスト 4: Godotの「すべて閉じる」との比較
1. 3つの未保存ファイルを開く
2. タブを右クリック → 「すべて閉じる」を実行
3. 1つ目のダイアログで「キャンセル」
4. 動作を記録
5. 同じ手順で `:qa` を実行
6. **期待**: 動作が一致する

**期待結果**: Godotの「すべて閉じる」と同じ動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 実装: PopupMenu.call_deferred("emit_signal", "id_pressed", FILE_MENU_CLOSE_ALL)
- on_script_close シグナルで Neovim バッファも削除
- Godot内部の "Can't make active a Viewport" エラーは対処不要（Godot側の問題）

---

### `/` / `?` - 検索
**状態**: 再テスト

**テスト手順**:
1. ファイルAで `/extends` で検索
2. `n` で次の結果に移動
3. `N` で前の結果に移動
4. `gt` でファイルBに切り替え
5. `n` でファイルBでも検索が継続することを確認

**期待結果**: 検索パターンがバッファ間で共有される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20
- 問題: 行数を増減した後に検索するとジャンプ先の行数がずれる
- 原因: `send_keys()` が非同期チャネルを使用、検索キーがNeovimで処理される前に `get_cursor()` を呼んでいた
- 修正: `send_search_and_sync_cursor()` で同期的input + poll + get_cursor を実行
- 2025-01-20 テスト通過

---

### `dd` / `cc` / `yy` - Operator-pending mode コマンド
**状態**: テスト済み

**テスト手順**:
1. 60行あるファイルを開く
2. `60G` で60行目に移動
3. `dd` で行を削除

**期待結果**: 1文字目の `d` でカーソルがジャンプしない

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20
- 問題: 1文字目の `d` で上の方にジャンプし、2文字目の `d` で元の行に戻って削除された
- 原因: operator-pending モードで `grid_cursor_goto` が画面相対位置 (3, 3) を返していた
- 修正: `skip_grid_cursor` 条件に `is_operator_pending` を追加（`src/plugin/neovim.rs:625`）
- 2025-01-20 テスト通過

---

### `ZQ` - 保存せずに閉じる
**状態**: テスト済み

**テスト手順**:
1. ファイルを編集（保存しない）
2. `ZQ` を実行
3. ファイルが閉じることを確認
4. 再度開いて変更が破棄されていることを確認

**期待結果**: 変更が破棄されてファイルが閉じる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

## 中優先度 (P2)

### `m{a-z}` / `'{a-z}` - Marks
**状態**: テスト済み

**テスト手順**:
1. ファイルAで `ma` でmark aを設定
2. カーソルを移動
3. `'a` でmark aの位置に戻る
4. ファイルBで `mb` でmark bを設定
5. ファイルAに戻り `'a` が正しく機能することを確認

**期待結果**: 各ファイルでmarksが独立して管理される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- `'a` は行頭にジャンプ（Vim標準動作）
- `` `a `` で正確な位置（行+列）にジャンプ

---

### `f` / `F` / `t` / `T` - 行内検索
**状態**: テスト済み

**テスト手順**:
1. `fx` で行内の文字xを前方検索
2. `;` で繰り返し
3. `,` で逆方向繰り返し
4. `Fx` で後方検索
5. `tx` / `Tx` でtill検索

**期待結果**: 行内検索が正しく機能する

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `:bn` / `:bp` - バッファナビゲーション
**状態**: テスト済み

**テスト手順**:
1. 複数ファイルを開く
2. `:bn` で次のバッファに移動
3. `:bp` で前のバッファに移動

**期待結果**: `gt`/`gT`と同じ動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### `:ls` / `:buffers` - バッファリスト
**状態**: テスト済み

**テスト手順**:
1. 複数ファイルを開く
2. `:ls` を実行
3. 開いているファイルがリスト表示されることを確認

**期待結果**: 開いているバッファがリスト表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- Godotコンソールにバッファリストが出力される（現状の仕様）

---

### `:wa` - 全て保存
**状態**: テスト済み

**テスト手順**:
1. 複数ファイルで編集
2. `:wa` を実行
3. 全ファイルのdirty markerが消えることを確認

**期待結果**: 全ファイルが保存される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 問題: dirty markerが更新されなかった
- 原因: ResourceSaver直接呼び出しでGodot UIが更新されていなかった
- 修正: FILE_MENU_SAVE_ALL (=7) を emit_signal で呼び出す方式に変更

---

### `:e!` - リロード
**状態**: テスト済み

**テスト手順**:
1. ファイルを編集
2. `:e!` を実行
3. 変更が破棄されてディスクの内容に戻ることを確認

**期待結果**: ファイルがディスクから再読み込みされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

---

## feature/combined-key-input ブランチ テスト

### 概要
- **ブランチ**: feature/combined-key-input
- **主な変更点**:
  - Unbounded channel方式でのキー入力送信
  - Mode transition buffer（Insert mode終了時のキー損失防止）
  - Insert/Replace modeでのタイムアウト処理スキップ
  - 設定保存の修正（neovim_clean）

---

### CK-T1: Insert mode 進入・維持（P0）
**状態**: テスト済み

**テスト手順**:
1. Godotを起動してスクリプトを開く
2. `o` を押してInsert modeに入る
3. **1秒以上待つ**
4. 文字を入力する

**期待結果**: Insert modeが維持され、文字が入力される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T2: Insert mode での高速入力（P0）
**状態**: テスト済み

**テスト手順**:
1. `o` でInsert modeに入る
2. スペースキーを押しっぱなしにして30文字以上入力
3. `Ctrl+[` または `Esc` でNormal modeに戻る
4. `0` で行頭、`$` で行末に移動

**期待結果**: 入力したスペースがすべて保存されている

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T3: 設定保存（neovim_clean）（P0）
**状態**: テスト済み

**テスト手順**:
1. Editor Settings > godot_neovim > `neovim_clean` を `true` に設定
2. Godotを再起動
3. ログで `Clean: true` を確認
4. `neovim_clean` を `false` に戻して再起動

**期待結果**: 設定が正しく保存・読み込みされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T4: 高速連続キー入力（Normal mode）（P1）
**状態**: テスト済み

**テスト手順**:
1. Normal modeで `jjjjjjjjjj`（10回）を高速入力

**期待結果**: 10行下に移動

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T5: カウント + モーション（P1）
**状態**: テスト済み

**テスト手順**:
1. Normal modeで `10j` を入力

**期待結果**: 10行下に移動

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T6: 削除コマンド（P1）
**状態**: テスト済み

**テスト手順**:
1. 文字がある行で `xxxxxxxxxx`（10回）を高速入力

**期待結果**: 10文字削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T7: モード遷移 + 即座の入力（P1）
**状態**: テスト済み

**テスト手順**:
1. `i` → 素早く `abc` → `Esc` → `j`

**期待結果**: "abc" が挿入され、1行下に移動

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T8: undo/redo（P1）
**状態**: テスト済み

**テスト手順**:
1. `o` でInsert mode、文字入力、`Esc`
2. `u` でundo
3. `Ctrl+r` でredo

**期待結果**: 正しくundo/redoされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T9: Visual mode選択（P1）
**状態**: テスト済み

**テスト手順**:
1. `v` でVisual mode
2. `l` で選択範囲拡大
3. `y` でyank
4. `p` でpaste

**期待結果**: 選択・コピー・貼り付けが動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 修正後テスト通過
- Visual mode中のカーソル同期をスキップ
- Visual mode中のタイムアウト処理をスキップ

---

### CK-T10: Replace mode（P1）
**状態**: テスト済み - Pass (Clean=true)

**テスト手順**:
1. `R` でReplace mode
2. 文字を入力（既存文字が置換される）
3. 1秒以上待つ
4. さらに文字を入力

**期待結果**: Replace modeが維持される

**テスト結果**:
- [x] Pass (Clean=true)
- [ ] Fail

**備考**: 2025-01-18 追加調査
- Clean=false時にカーソルジャンプ発生
- Clean=true時は正常動作（cursor=(2,0)のまま）
- nvim直接起動（--cleanなし）ではジャンプしない → ユーザー設定単体は問題なし
- nvim_input経由でも直接実行ではジャンプしない
- **godot-neovim + ユーザー設定の相互作用が原因**
- 疑わしいプラグイン:
  - copilot.vim (GitHub Copilot) - Insert/Replace mode進入時に動作
  - lexima.vim (auto-pairs) - mode変更時に動作する可能性
  - FixCursorHold.nvim - CursorHold修正
- 調査用ログで確認: R押下時点でGodot/Neovimカーソルは一致(2,0)、Neovim処理後に(2,4)に移動

---

### CK-T11: ファイル切り替え（P2）
**状態**: テスト済み

**テスト手順**:
1. スクリプトAを編集
2. スクリプトBに切り替え
3. スクリプトAに戻る

**期待結果**: カーソル位置と内容が保持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T12: 保存と:w（P2）
**状態**: テスト済み

**テスト手順**:
1. 編集を行う
2. `:w` で保存

**期待結果**: Godot側でも保存される（dirty flagがクリア）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T13: :q でファイルを閉じる（P2）
**状態**: テスト済み

**テスト手順**:
1. スクリプトを編集
2. `:q` で閉じる

**期待結果**: 保存確認ダイアログが表示される（または保存済みなら閉じる）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T14: タイムアウト（Normal mode）（P2）
**状態**: テスト済み

**テスト手順**:
1. Normal modeで `d` を押す
2. 1秒以上待つ

**期待結果**: `Key sequence timeout` ログが出て、オペレータがキャンセルされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過

---

### CK-T15: Clean mode での動作（P2）
**状態**: テスト済み

**テスト手順**:
1. `neovim_clean = true` に設定
2. Godot再起動
3. CK-T1〜CK-T9 を実行

**期待結果**: ユーザー設定なしでも基本動作が正常

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-18 テスト通過（全テストをClean=trueで実行済み）

---

---

## 回帰テスト（コミット履歴から抽出したバグパターン）

以下のテストはfeature/combined-key-inputブランチで修正されたバグに基づく回帰テスト。

### カテゴリ1: モード遷移・タイムアウト

#### RT-01: Insert mode中のタイムアウト
**修正コミット**: 23aef63
**バグ**: Insert mode中に1秒経過するとタイムアウトが発生してEscが送信される

**テスト手順**:
1. `i` でInsert modeに入る
2. 何も入力せず2秒待つ
3. 文字を入力

**期待結果**: Insert modeが維持され、文字が正常に入力される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-02: Replace mode中のタイムアウト
**修正コミット**: 23aef63
**バグ**: Replace mode中に1秒経過するとタイムアウトが発生

**テスト手順**:
1. `R` でReplace modeに入る
2. 何も入力せず2秒待つ
3. 文字を入力（上書きされる）

**期待結果**: Replace modeが維持され、文字が上書きされる
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-03: Visual mode中のタイムアウト
**修正コミット**: 9f5c787
**バグ**: Visual mode中に1秒経過するとタイムアウトが発生

**テスト手順**:
1. `v` でVisual modeに入る
2. 何も入力せず2秒待つ
3. `j` で選択を拡大

**期待結果**: Visual modeが維持され、選択範囲が拡大される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-04: モード名の認識（短い名前 vs 長い名前）
**修正コミット**: fa65907
**バグ**: Neovimが"insert"を返すと"i"と認識されずNormal modeとして処理される

**テスト手順**:
1. `i` でInsert modeに入る
2. 文字を入力
3. モード表示が"INSERT"であることを確認
4. 文字がバッファに正常に入力されることを確認

**期待結果**: Insert modeが正しく認識され、文字入力が機能する
**テスト結果**: [x] Pass / [ ] Fail

---

### カテゴリ2: カーソル同期

#### RT-05: Visual mode中のカーソル同期ループ
**修正コミット**: 9f5c787
**バグ**: Visual modeで移動するとカーソルが行末にジャンプしてから移動する

**テスト手順**:
1. 行の途中にカーソルを置く
2. `v` でVisual modeに入る
3. `j` で下に移動

**期待結果**: カーソルが直接下の行に移動する（行末を経由しない）
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-06: 高速キー入力時のタイムアウト
**修正コミット**: 141b79b
**バグ**: 連続してキーを押すとRPC呼び出しでタイムアウトが発生

**テスト手順**:
1. Normal modeで `jjjjjjjjjj`（10回）を素早く入力

**期待結果**: フリーズせず10行下に移動する
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-07: タブ文字がある行でのカーソル位置
**修正コミット**: 141b79b
**バグ**: タブ文字がある行でカーソル位置がずれる（画面位置とバイト位置の違い）

**テスト手順**:
1. タブ文字を含む行（例: `\tfunc test():`）を作成
2. その行でカーソルを移動
3. `gt` で別ファイルに切り替え
4. `gT` で戻る

**期待結果**: カーソル位置が正しく復元される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-08: Godotの末尾空行でのカーソル位置
**修正コミット**: a1225fd
**バグ**: Godotの末尾空行をクリックするとNeovimに存在しない行に同期しようとする

**テスト手順**:
1. ファイルの最終行の下（Godotが表示する空行）をクリック
2. Normal modeでコマンドを実行（例: `k`）

**期待結果**: エラーなく動作する
**テスト結果**: [x] Pass / [ ] Fail

---

### カテゴリ3: キー入力

#### RT-09: Insert mode終了時のキー損失
**修正コミット**: 4ca3442
**バグ**: `<Esc>j` を素早く入力するとjが無視される

**テスト手順**:
1. `i` でInsert modeに入る
2. `abc` と入力
3. `<Esc>j` を素早く入力

**期待結果**: Normal modeに戻り、1行下に移動する
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-10: カウント付きモーション
**修正コミット**: 4ca3442
**バグ**: `10j` のようなカウント付きコマンドで数字が失われる

**テスト手順**:
1. ファイルの先頭で `10j` を入力

**期待結果**: 10行下に移動する
**テスト結果**: [x] Pass / [ ] Fail

---

### カテゴリ4: ファイル保存・クローズ

#### RT-11: :wq でファイルが閉じない
**修正コミット**: 509486d
**バグ**: :wq を実行してもファイルが閉じない

**テスト手順**:
1. ファイルを編集
2. `:wq` を実行

**期待結果**: ファイルが保存されて閉じる
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-12: 保存時にダイアログが表示される
**修正コミット**: 509486d
**バグ**: :w で保存しようとすると「変更を保存しますか」ダイアログが表示される

**テスト手順**:
1. ファイルを編集
2. `:w` を実行

**期待結果**: ダイアログなしで保存される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-13: ファイルクローズ後のカーソル位置復元
**修正コミット**: a258a88
**バグ**: ファイルを閉じて再度開くとカーソル位置が復元されない

**テスト手順**:
1. ファイルを開いて50行目に移動
2. `:q` で閉じる
3. 同じファイルを再度開く

**期待結果**: カーソルが50行目に復元される
**テスト結果**: [x] Pass / [ ] Fail

---

### カテゴリ5: Dirty flag（未保存マーク）

#### RT-14: ファイルオープン時のdirty flag
**修正コミット**: d4f6f00
**バグ**: ファイルを開いただけでdirty flag（*）が表示される

**テスト手順**:
1. ファイルを開く（編集しない）

**期待結果**: dirty flag（*）が表示されない
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-15: キー入力でdirty flagがクリアされる
**修正コミット**: 5086557
**バグ**: 編集後にhjkl等を押すとdirty flagが消える

**テスト手順**:
1. ファイルを編集（dirty flag表示）
2. `j` で1行下に移動

**期待結果**: dirty flagが維持される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-16: Undo/Redo後のdirty flag
**修正コミット**: 5086557
**バグ**: Undoで初期状態に戻してもdirty flagが消えない

**テスト手順**:
1. ファイルを編集（1回のみ）
2. `u` でUndo

**期待結果**: 初期状態に戻りdirty flagが消える
**テスト結果**: [x] Pass / [ ] Fail

---

### カテゴリ6: マルチバッファ

#### RT-17: バッファ切り替え時のカーソル位置独立性
**修正コミット**: 87234a6
**バグ**: ファイル切り替え時に前のファイルのカーソル位置が失われる

**テスト手順**:
1. ファイルAの30行目にカーソルを置く
2. `gt` でファイルBに切り替え
3. ファイルBの10行目にカーソルを置く
4. `gT` でファイルAに戻る
5. `gt` でファイルBに戻る

**期待結果**: A=30行目、B=10行目が保持される
**テスト結果**: [x] Pass / [ ] Fail

---

#### RT-18: バッファ切り替え時のUndo履歴独立性
**修正コミット**: 87234a6
**バグ**: ファイルAでUndoするとファイルBの変更がUndoされる

**テスト手順**:
1. ファイルAで編集
2. `gt` でファイルBに切り替え
3. ファイルBで編集
4. `gT` でファイルAに戻る
5. `u` でUndo

**期待結果**: ファイルAの変更のみUndoされる
**テスト結果**: [x] Pass / [ ] Fail

**備考**: 2025-01-19 修正済み
- 問題: 編集後に`gt`で切り替えるとdirty flagがクリアされ、undoできない
- 原因: Lua側で行数チェックによりバッファが再初期化され、undo履歴がリセット
- 修正: `init.lua`の行数チェックを削除、未初期化バッファのみ初期化

---

## 回帰テスト実行履歴

| 日付 | バージョン/ブランチ | 実行者 | 結果 | 備考 |
|------|-------------------|--------|------|------|
| 2025-01-19 | feature/combined-key-input | - | 18/18 Pass | RT-18修正後全Pass |

---

## テスト履歴

| 日付 | テスター | テスト項目 | 結果 | 備考 |
|------|---------|-----------|------|------|
| 2025-01-18 | - | CK-T1, CK-T2, CK-T3 (P0) | Pass | feature/combined-key-input ブランチ |
| 2025-01-18 | - | CK-T4, CK-T5, CK-T6, CK-T7, CK-T8 (P1) | Pass | |
| 2025-01-18 | - | CK-T9 (P1) | Pass | Visual mode修正後 |
| 2025-01-18 | - | CK-T10 (P1) | Pass* | Clean=true正常、Clean=false時はプラグイン相互作用要調査(copilot/lexima等) |
| 2025-01-18 | - | CK-T11, CK-T12, CK-T13, CK-T14, CK-T15 (P2) | Pass | 全P2テスト通過 |

---

## DLLホットリロード関連テスト

### HR-T1: DLLホットリロード時のカーソル同期エラー（P1）
**状態**: テスト済み

**テスト手順**:
1. Godotでテストプロジェクトを開く
2. スクリプトファイルを開いて、10行目以降にカーソルを移動
3. DLLをビルドして上書きコピー: `cp target/debug/godot_neovim.dll ~/dev/godot-camerafeed-demo/addons/godot-neovim/bin/windows/`
4. Godotが自動的にDLLをリロードする
5. コンソールにエラーが出ないことを確認

**期待結果**: `Failed to sync cursor` エラーが発生しない

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過。`sync_cursor_to_neovim: Buffer not initialized, skipping` ログ確認

---

### HR-T2: DLLホットリロード後の通常動作（P1）
**状態**: テスト済み

**テスト手順**:
1. HR-T1の手順を実行後
2. スクリプトファイルを再度開く（タブをクリック）
3. `j`, `k` でカーソルを上下に移動
4. `i` でInsert mode、文字入力、`Esc` でNormal mode

**期待結果**: 通常通りカーソル同期と入力が動作する

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過。カーソル移動、gt/gT、dd、:w など正常動作

---

## 未使用メソッド削除テスト

### 概要
Neovim Master設計により不要になったGodot側編集メソッドを削除。
これらのコマンドはNeovim経由で処理されるため、引き続き動作するはず。

削除したメソッド:
- `delete_char_forward` (x), `delete_char_backward` (X)
- `substitute_char` (s), `substitute_line` (S/cc)
- `delete_to_eol` (D), `change_to_eol` (C), `yank_to_eol` (Y)

---

### UM-T1: x コマンド（カーソル下の文字削除）
**状態**: テスト済み

**テスト手順**:
1. 文字がある行にカーソルを置く
2. `x` を押す

**期待結果**: カーソル下の文字が削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T2: X コマンド（カーソル前の文字削除）
**状態**: テスト済み

**テスト手順**:
1. 行の途中にカーソルを置く
2. `X` を押す

**期待結果**: カーソル前の文字が削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T3: s コマンド（文字置換）
**状態**: テスト済み

**テスト手順**:
1. 文字がある行にカーソルを置く
2. `s` を押す
3. 新しい文字を入力
4. `Esc` でNormal modeに戻る

**期待結果**: 元の文字が削除され、新しい文字が挿入される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T4: S コマンド（行全体置換）
**状態**: テスト済み

**テスト手順**:
1. テキストがある行にカーソルを置く
2. `S` を押す
3. 新しいテキストを入力
4. `Esc` でNormal modeに戻る

**期待結果**: 行がクリアされ（インデント保持）、Insert modeで入力できる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T5: cc コマンド（行全体置換、Sと同等）
**状態**: テスト済み

**テスト手順**:
1. テキストがある行にカーソルを置く
2. `cc` を押す
3. 新しいテキストを入力
4. `Esc` でNormal modeに戻る

**期待結果**: Sと同じ動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T6: D コマンド（カーソルから行末まで削除）
**状態**: テスト済み

**テスト手順**:
1. 行の途中にカーソルを置く
2. `D` を押す

**期待結果**: カーソル位置から行末までが削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T7: C コマンド（カーソルから行末まで変更）
**状態**: テスト済み

**テスト手順**:
1. 行の途中にカーソルを置く
2. `C` を押す
3. 新しいテキストを入力
4. `Esc` でNormal modeに戻る

**期待結果**: カーソル位置から行末までが削除され、Insert modeで入力できる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T8: Y コマンド（行全体ヤンク）
**状態**: テスト済み

**テスト手順**:
1. テキストがある行にカーソルを置く
2. `Y` を押す
3. 別の行に移動
4. `p` を押す

**期待結果**: 行全体がコピーされ、貼り付けられる（Vimの標準動作: Y = yy）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T9: dd コマンド（既存機能の確認）
**状態**: テスト済み

**テスト手順**:
1. テキストがある行にカーソルを置く
2. `dd` を押す

**期待結果**: 行が削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T10: yy + p コマンド（既存機能の確認）
**状態**: テスト済み

**テスト手順**:
1. テキストがある行にカーソルを置く
2. `yy` でヤンク
3. 別の行に移動
4. `p` でペースト

**期待結果**: 行が複製される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### UM-T11: u コマンド（Undo確認）
**状態**: テスト済み

**テスト手順**:
1. 上記テスト（UM-T1〜UM-T10）で変更を加える
2. `u` を押す

**期待結果**: 変更が取り消される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

## dead_code削除テスト

### 概要
未使用の`#[allow(dead_code)]`メソッド・フィールドを削除。
削除した項目:
- `sync/mod.rs`: `is_attached`, `register_godot_change`, `is_nvim_change`, `changedtick`
- `plugin/neovim.rs`: `sync_buffer_from_neovim`, `sync_modified_flag`
- `plugin/mod.rs`: `pending_modified_sync` フィールド
- `plugin/registers.rs`: `yank_line_to_register`, `delete_line_to_register`

テスト対象: 削除したコードに関連する機能が影響を受けていないことを確認

---

### DC-T1: バッファ同期（Neovim → Godot）
**状態**: テスト済み

**テスト手順**:
1. スクリプトファイルを開く
2. `dd` で行を削除
3. Godot側に変更が反映されることを確認

**期待結果**: 行が削除される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### DC-T2: Undo後のdirty flag同期
**状態**: テスト済み

**テスト手順**:
1. ファイルを開く（dirty flagなし）
2. `o` で新しい行を追加、`Esc`
3. dirty flag（*）が表示されることを確認
4. `u` でUndo
5. dirty flagが消えることを確認

**期待結果**: Undoで変更が取り消されるとdirty flagが消える

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### DC-T3: タブ切り替え
**状態**: テスト済み

**テスト手順**:
1. 2つのスクリプトファイルを開く
2. `gt` でタブ切り替え
3. カーソル位置が各ファイルで独立して保持されることを確認

**期待結果**: タブ切り替えが正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---

### DC-T4: 名前付きレジスタ（yy, dd, p）
**状態**: テスト済み

**テスト手順**:
1. `"ayy` でレジスタaに行をヤンク
2. 別の行に移動
3. `"ap` でレジスタaからペースト

**期待結果**: 名前付きレジスタが動作する

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。タイムアウト処理との干渉問題を修正（`"`キー処理でlast_keyをクリア）

---

### DC-T5: 基本編集操作
**状態**: テスト済み

**テスト手順**:
1. `i` でInsert mode、文字入力、`Esc`
2. `x` で文字削除
3. `dd` で行削除
4. `u` でUndo

**期待結果**: 基本的な編集操作が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-19 テスト通過

---


## ビューポート同期 (VP) - win_viewport イベント

### VP-T1: zz (カーソル行を画面中央に)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `50G` で50行目へ移動
3. `zz` でカーソル行を画面中央にスクロール
4. カーソル行が画面中央付近に表示されることを確認

**期待結果**: カーソル行が画面中央にスクロールされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T2: zt / zb (カーソル行を画面上部/下部に)
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. `zt` でカーソル行を画面上部にスクロール
4. カーソル行が画面上部に表示されることを確認
5. `zb` でカーソル行を画面下部にスクロール
6. カーソル行が画面下部に表示されることを確認

**期待結果**: zt/zbでカーソル行が画面上部/下部にスクロールされる

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過（VP-T1と同時にテスト）

---

### VP-T3: Ctrl+F / Ctrl+B (ページスクロール)
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `1G` でファイル先頭へ移動
3. `Ctrl+F` で1ページ下にスクロール
4. スクロール位置とカーソル位置が更新されることを確認
5. `Ctrl+B` で1ページ上にスクロール
6. スクロール位置とカーソル位置が戻ることを確認

**期待結果**: Ctrl+F/Bでページ単位のスクロールが動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20
- Ctrl+F: OK（約30行ずつ下にスクロール）
- Ctrl+B: 修正済み
  - 問題: ext_multigrid環境でファイル末尾のviewport heightが正しく報告されず、カーソルが1行しか動かなかった
  - 修正: Ctrl+B後にカーソルがビューポート下部にある場合、上部に補正する処理を追加

---

### VP-T4: Ctrl+D / Ctrl+U (半ページスクロール)
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `1G` でファイル先頭へ移動
3. `Ctrl+D` で半ページ下にスクロール
4. スクロール位置とカーソル位置が更新されることを確認
5. `Ctrl+U` で半ページ上にスクロール
6. スクロール位置とカーソル位置が戻ることを確認

**期待結果**: Ctrl+D/Uで半ページ単位のスクロールが動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T5: H / M / L (画面位置へカーソル移動)
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. `H` で画面上部にカーソル移動
4. カーソルが画面上部（表示範囲の先頭付近）に移動することを確認
5. `M` で画面中央にカーソル移動
6. カーソルが画面中央に移動することを確認
7. `L` で画面下部にカーソル移動
8. カーソルが画面下部（表示範囲の末尾付近）に移動することを確認

**期待結果**: H/M/Lで画面内の上部/中央/下部にカーソルが移動

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T6: 既存機能の回帰テスト
**状態**: テスト済み

**テスト手順**:
1. `i` でInsert mode、文字入力、`Esc`
2. `x` で文字削除
3. `dd` で行削除
4. `u` でUndo
5. `gt` / `gT` でタブ切り替え

**期待結果**: 既存の編集・ナビゲーション機能が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T7: Ctrl+Y / Ctrl+E (1行スクロール)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（50行以上）を開く
2. `30G` で30行目へ移動
3. `Ctrl+Y` で1行上にスクロール（カーソルは移動しない）
4. 画面が1行上にスクロールしたことを確認
5. `Ctrl+E` で1行下にスクロール（カーソルは移動しない）
6. 画面が1行下にスクロールしたことを確認

**期待結果**: Ctrl+Y/Eで1行単位のスクロールが動作（カーソル位置は変わらない）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T8: マウスクリック時のビューポート維持
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. 現在のスクロール位置を確認（画面に表示されている行番号）
4. 画面内の任意の位置をマウスでクリック
5. スクロール位置が変化していないことを確認
6. カーソルがクリック位置に移動していることを確認

**期待結果**: クリック時にスクロール位置は変化しない（カーソルのみ移動）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 初回テスト: ラベルのカーソル位置が更新されない問題を発見
- 修正: `on_caret_changed`に`update_mode_display_with_cursor`を追加

---

### VP-T9: Visual mode でのビューポート維持
**状態**: テスト済み

**テスト手順**:
1. 長いファイルを開く
2. `30G` で30行目へ移動
3. `v` でVisual mode
4. `j` で10行下に選択を拡大
5. 選択範囲が正しく表示されることを確認
6. スクロール位置が適切に維持されることを確認（選択がスクロールアウトしない限り）

**期待結果**: Visual modeで選択操作時にビューポートが正しく動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T10: H/M/L後の移動コマンド
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. `H` で画面上部に移動
4. `j` で1行下に移動
5. カーソルが正しく移動することを確認
6. ビューポートが維持されることを確認
7. `M` で画面中央に移動後、`k` で1行上に移動
8. `L` で画面下部に移動後、`j` で1行下に移動

**期待結果**: H/M/L後の移動コマンドが正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T11: ページスクロール後の編集
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `Ctrl+F` で1ページ下にスクロール
3. `i` でInsert mode、文字入力、`Esc`
4. 入力した文字が正しく表示されることを確認
5. `u` でUndo
6. `Ctrl+B` で1ページ上にスクロール
7. 上記の操作を繰り返し

**期待結果**: スクロール後の編集が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T12: zz/zt/zb 後の編集
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. `zz` で中央にスクロール
4. `i` でInsert mode、文字入力、`Esc`
5. 入力した文字が正しく表示されることを確認
6. `zt` で上部にスクロール後、編集
7. `zb` で下部にスクロール後、編集

**期待結果**: zz/zt/zb後の編集が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T13: gg / G との組み合わせ
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `G` でファイル末尾へ移動
3. ビューポートが末尾を表示することを確認
4. `H` で画面上部に移動
5. `gg` でファイル先頭へ移動
6. ビューポートが先頭を表示することを確認
7. `L` で画面下部に移動

**期待結果**: gg/Gとの組み合わせが正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T14: Godotウィンドウリサイズ
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. Godotウィンドウをリサイズ（高さを変更）
4. `Resized Neovim UI` ログが表示されることを確認
5. `zz` でカーソル行を中央に
6. 新しいウィンドウサイズに合わせて中央に表示されることを確認

**期待結果**: ウィンドウリサイズ後もビューポート同期が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### VP-T15: 下部ペイン表示切替
**状態**: Pass

**テスト手順**:
1. 長いファイルを開く
2. `50G` で50行目へ移動
3. Godotの下部ペイン（Output等）を表示
4. `Resized Neovim UI` ログが表示されることを確認
5. `zz` でカーソル行を中央に
6. 新しい表示領域に合わせて中央に表示されることを確認
7. 下部ペインを閉じて同様の操作を行う

**期待結果**: 下部ペイン表示切替後もビューポート同期が正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

## ビューポート同期 回帰テスト実行履歴

| 日付 | バージョン/ブランチ | 実行者 | 結果 | 備考 |
|------|-------------------|--------|------|------|
| - | - | - | - | - |

---

## モード遷移時のカーソル位置 回帰テスト (MT)

### 概要
`ext_multigrid`有効時、`grid_cursor_goto`は画面相対位置を返す。
モード遷移時に`viewport_change`がない場合、誤った位置がGodotに適用される問題の回帰テスト。

**修正内容**:
- `skip_grid_cursor`フラグで以下のモード遷移時に`grid_cursor_goto`からのカーソル同期をスキップ
- `current_cursor`（最後の正しいバッファ位置）を使用

**カバーするモード遷移**:
| 遷移 | フラグ |
|------|--------|
| Normal → Insert | `entering_insert` |
| Insert → Normal | `leaving_insert` |
| Normal → Visual | `entering_visual` |
| Visual → Normal | `leaving_visual` |

---

### MT-T1: Normal → Insert (entering_insert)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール（例: 50行目付近へ）
3. 現在のカーソル位置を確認
4. `i` でInsert modeに入る
5. カーソル位置が変わっていないことを確認
6. カーソルタイプがLINE（縦棒）に変わっていることを確認
7. `Esc` でNormal modeに戻る

**期待結果**: Insert mode進入時にカーソル位置が維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`entering_insert`フラグによる保護

---

### MT-T2: Insert → Normal (leaving_insert)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール（例: 50行目付近へ）
3. `i` でInsert modeに入る
4. 数文字入力
5. `Esc` でNormal modeに戻る
6. カーソル位置が入力した位置の1つ前（Vimの標準動作）にあることを確認
7. カーソルタイプがBLOCK（四角）に戻っていることを確認

**期待結果**: Insert mode終了時にカーソル位置が正しい（画面先頭にジャンプしない）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`leaving_insert`フラグによる保護

---

### MT-T3: Normal → Visual (entering_visual)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール（例: 50行目付近へ）
3. `j` で数行移動（例: 55行目）
4. 現在のカーソル位置を確認
5. `v` でVisual modeに入る
6. カーソル位置が変わっていないことを確認
7. 選択開始位置が正しいことを確認（55行目）
8. `Esc` でNormal modeに戻る

**期待結果**: Visual mode進入時にカーソル位置が維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`entering_visual`フラグによる保護

---

### MT-T4: Visual → Normal (leaving_visual)
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール（例: 50行目付近へ）
3. `v` でVisual modeに入る
4. `j` で5-10行下まで選択を拡大
5. 選択終了位置を確認（例: 60行目）
6. `Esc` でNormal modeに戻る
7. カーソル位置が選択終了位置（60行目）にあることを確認
8. 画面上部にジャンプしていないことを確認

**期待結果**: Visual mode終了時にカーソル位置が正しい（選択終了位置に残る）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`leaving_visual`フラグによる保護

---

### MT-T5: Visual Line Mode (V) 遷移
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `V` でVisual Line modeに入る
4. 現在行が選択されることを確認
5. `j` で5行下まで選択を拡大
6. 各行が正しく選択されていることを確認
7. `Esc` でNormal modeに戻る
8. カーソル位置が正しいことを確認

**期待結果**: Visual Line mode進入/終了時にカーソル位置が維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`entering_visual`/`leaving_visual`フラグで保護（`V`もvisual modeとして認識）

---

### MT-T6: H/M/L + Insert mode 遷移
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `H` で画面上部に移動
4. カーソルが画面上部にあることを確認
5. `i` でInsert modeに入る
6. カーソル位置が変わっていないことを確認
7. カーソルタイプがLINE（縦棒）に変わっていることを確認
8. `Esc` → `M` → `i` で画面中央からInsert mode
9. `Esc` → `L` → `i` で画面下部からInsert mode

**期待結果**: H/M/L後のInsert mode進入でカーソル位置が維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。H/M/Lはviewport_changeなしでカーソル移動、その後のinsertも保護が必要

---

### MT-T7: H/M/L + Visual mode 遷移
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `H` で画面上部に移動
4. `v` でVisual modeに入る
5. カーソル位置が画面上部のままであることを確認
6. `L` で画面下部まで選択
7. 選択範囲が正しいことを確認
8. `Esc` でNormal modeに戻る
9. カーソルが画面下部にあることを確認

**期待結果**: H/M/L後のVisual mode操作でカーソル位置が正しい

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 初回: step.5のLで選択が解除される問題を発見
- 原因: `cancel_pending_operator()`がvisual modeでEscを送信
- 修正: MT-T11の回帰テストに詳細記載

---

### MT-T8: 連続モード遷移
**状態**: Pass

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. 以下の操作を連続で実行:
   - `i` → `abc` → `Esc` (Insert → Normal)
   - `v` → `jjj` → `Esc` (Visual → Normal)
   - `V` → `jj` → `Esc` (Visual Line → Normal)
   - `i` → `def` → `Esc` (Insert → Normal)
4. 各モード遷移でカーソル位置が正しいことを確認

**期待結果**: 連続モード遷移でもカーソル位置が正しく維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### MT-T9: Replace mode 遷移
**状態**: テスト済み

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. 現在のカーソル位置を確認
4. `R` でReplace modeに入る
5. カーソル位置が変わっていないことを確認
6. 数文字入力（上書き）
7. `Esc` でNormal modeに戻る
8. カーソル位置が正しいことを確認

**期待結果**: Replace mode進入/終了時にカーソル位置が維持される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。Replace modeは`entering_insert`/`leaving_insert`で保護

---

### MT-T10: use-after-free 回帰テスト
**状態**: Pass

**テスト手順**:
1. 2つ以上のスクリプトファイルを開く
2. ファイルAで編集操作
3. `gt` でファイルBに切り替え
4. ファイルBで `Ctrl+F` でスクロール
5. `v` でVisual mode → `j` で選択拡大 → `Esc`
6. `gt` でファイルAに戻る
7. 上記操作を5回以上繰り返す

**期待結果**: クラッシュせずにスクリプト切り替えが動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`current_editor`の`is_instance_valid()`チェックによる保護

---

### MT-T11: Visual mode + H/M/L 選択拡大（回帰テスト）
**状態**: テスト済み

**背景**: H/M/Lキーがvisual modeで選択を解除してしまうバグの回帰防止

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `H` で画面上部に移動
4. `v` でVisual modeに入る（選択開始）
5. `L` で画面下部まで選択を拡大
6. **確認**: 選択範囲がHの位置からLの位置まで正しく表示されている
7. `M` で画面中央まで選択を縮小
8. **確認**: 選択範囲がHの位置からMの位置に変わっている
9. `Esc` でNormal modeに戻る

**期待結果**: Visual mode中のH/M/Lで選択範囲が正しく拡大/縮小される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 原因: `cancel_pending_operator()`がvisual modeでもEscを送信していた
- 修正1: H/M/L処理でvisual mode時は`cancel_pending_operator()`を呼ばない
- 修正2: visual mode進入時に`last_key`をクリア
- 修正3: visual mode中は`last_key`を設定しない

---

### MT-T12: Visual mode進入後のlast_keyクリア（回帰テスト）
**状態**: テスト済み

**背景**: visual mode進入時に'v'が`last_key`に残り、後続のコマンドでEscが送信されるバグの回帰防止

**テスト手順**:
1. ファイルを開く
2. `v` でVisual modeに入る
3. `j` で数行下まで選択を拡大
4. **確認**: 選択が正しく拡大されている（Escで解除されない）
5. `y` でヤンク
6. **確認**: 選択範囲がヤンクされてNormal modeに戻る
7. `p` でペースト
8. **確認**: 正しくペーストされる

**期待結果**: visual mode進入時に`last_key`がクリアされ、後続のコマンドが正常動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- `entering_visual`時に`clear_last_key()`を呼ぶことで'v'がクリアされる

---

### MT-T13: Pending operator + H/M/L（回帰テスト）
**状態**: Pass

**背景**: normal modeでのpending operator（d, c, y等）とH/M/Lの組み合わせが正常動作することを確認

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `M` で画面中央に移動
4. `dH` で画面上部まで削除
5. **確認**: 画面中央から上部までの行が削除される
6. `u` でUndo
7. `yL` で画面下部までヤンク
8. **確認**: ヤンクが成功（ステータスに行数表示など）
9. `cM` で画面中央までchange
10. **確認**: Insert modeに入り、該当範囲が削除される
11. `Esc` でNormal modeに戻る

**期待結果**: pending operator + H/M/Lが正常に動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過
- 初回: `cancel_pending_operator()`がoperator-pending modeでEscを送信し、dH/yL/cMが動作しない問題を発見
- 修正1: H/M/Lで`cancel_pending_operator()`を呼ばないように変更
- 修正2: `was_operator_pending`フラグ追加で、operator完了後の`grid_cursor_goto`をスキップ

---

### MT-T14: Normal mode H/M/L 基本動作（回帰テスト）
**状態**: Pass

**背景**: H/M/Lから`cancel_pending_operator`を削除したことによる回帰防止

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `H` で画面上部に移動
4. **確認**: カーソルが画面上部（ビューポート1行目付近）にある
5. `L` で画面下部に移動
6. **確認**: カーソルが画面下部（ビューポート最終行付近）にある
7. `M` で画面中央に移動
8. **確認**: カーソルが画面中央にある

**期待結果**: H/M/Lの基本的なカーソル移動が正常動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: H/M/Lはすべてのコンテキストで有効なモーション

---

### MT-T15: Operator-pending + H/M/L 連続操作（回帰テスト）
**状態**: Pass

**背景**: `was_operator_pending`追加による連続操作の回帰防止

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `M` で画面中央に移動、位置を記録（例: 45行目）
4. `yH` でヤンク
5. **確認**: カーソルがH位置（画面上部）に移動（ヤンク範囲の開始位置）
6. `M` で再度画面中央に戻る
7. `yL` でヤンク
8. **確認**: カーソルがM位置のまま（ヤンク範囲の開始位置がM）
9. `yM` でヤンク
10. **確認**: カーソルがM位置のまま（同じ位置）
11. `dH` で削除
12. **確認**: 行が削除され、カーソルが画面上部に移動
13. `u` でUndo
14. `dL` で削除
15. **確認**: 行が削除され、カーソルが元の位置（削除開始位置）にある

**期待結果**: 連続したoperator+H/M/L操作が正常動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: Vim/Neovimの動作: `y{motion}`はヤンク範囲の開始位置にカーソルを移動。yHは上方向なのでカーソルがH位置に移動、yLは下方向なのでカーソルは元の位置（開始位置）のまま

---

### MT-T16: Visual mode → Operator-pending 切り替え（回帰テスト）
**状態**: Pass

**背景**: visual modeとoperator-pending modeの切り替え時の回帰防止

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `H` で画面上部に移動
4. `v` でVisual modeに入る
5. `L` で画面下部まで選択
6. **確認**: 選択範囲が正しい
7. `Esc` でNormal modeに戻る
8. `M` で画面中央に移動
9. `dH` で画面上部まで削除
10. **確認**: 削除が正常に動作
11. `u` でUndo
12. `v` でVisual modeに入る
13. `M` で画面中央まで選択
14. `y` でヤンク
15. **確認**: ヤンクが成功しNormal modeに戻る

**期待結果**: visual modeとoperator-pending modeの切り替えが正常動作

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: visual mode + H/M/LとdH/yL等の混合操作

---

### MT-T17: カウント付きoperator + H/M/L（回帰テスト）
**状態**: Pass

**背景**: カウント付き操作の回帰防止

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `Ctrl+F` で1ページ下にスクロール
3. `M` で画面中央に移動
4. `2yH` で2回分（現在行からH位置まで2回分）をヤンク
5. **確認**: カーソルがH位置に移動（ヤンク範囲の開始位置、Vim標準動作）
6. `M` で再度画面中央に戻る
7. `3dL` で3回分を削除（Vimの動作に依存）
8. `u` でUndo
9. **確認**: 削除が元に戻る

**期待結果**: カウント付きoperator+H/M/Lが動作（動作はVim依存）

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: カウントの解釈はVim/Neovimの実装に依存。`y{motion}`はヤンク範囲の開始位置にカーソルを移動するのがVim標準動作

---

## モード遷移回帰テスト 実行履歴

| 日付 | バージョン/ブランチ | 実行者 | 結果 | 備考 |
|------|-------------------|--------|------|------|
| - | - | - | - | - |

---

## ローカル処理コマンドのNeovim同期テスト (LP)

### 概要
ローカル処理されるモーションコマンドがNeovimにも正しく送信されることを確認する。
これにより以下が保証される:
- Neovimのカーソル位置がGodotと同期
- マクロ記録に含まれる
- `.`コマンドでの繰り返しが正しく動作

**修正対象コマンド**:
| カテゴリ | コマンド | send_keys内容 |
|---------|---------|--------------|
| g-prefix motion | `ge`, `gj`, `gk` | `ge`, `gj`, `gk` |
| g-prefix other | `gI`, `gi`, `g&`, `gJ`, `gp`, `gP` | 各コマンド |
| g-prefix fallback | `gg`, `g$`, `g0`, `g^`, `g_` | `g{key}` |
| Character search | `f{char}`, `F{char}`, `t{char}`, `T{char}` | `f{char}`等 |
| Repeat search | `;`, `,` | `;`, `,` |
| Bracket jump | `[{`, `[(`, `]}`, `])` | 各コマンド |
| Method jump | `[m`, `]m` | 各コマンド |
| Matching bracket | `%` | `%` |

---

### LP-T1: ge コマンド（前の単語末尾へ移動）
**状態**: Pass

**テスト手順**:
1. GDScriptファイルを開く
2. 以下のようなコードがある行に移動:
   ```
   var some_long_variable_name = 123
   ```
3. 行末（`= 123`の`3`）にカーソルを置く
4. `ge` を押す
5. カーソルが`name`の`e`に移動することを確認
6. もう一度 `ge` を押す
7. カーソルが`variable`の`e`に移動することを確認

**期待結果**: 前の単語の末尾に正しく移動する

**Neovim同期確認**:
- ログに `send_keys: ge` が表示される
- `ge` がNeovimのカーソル位置と一致する

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T2: gj / gk コマンド（表示行単位の移動）
**状態**: Pass

**テスト手順**:
1. GDScriptファイルを開く
2. Godotエディタの幅を狭くして、長い行が折り返されるようにする
3. 折り返されている長い行にカーソルを置く
4. `gj` を押す
5. カーソルが折り返された次の表示行に移動することを確認
6. `gk` を押す
7. カーソルが元の表示行に戻ることを確認

**期待結果**: 表示行（折り返し行）単位で移動する

**Neovim同期確認**:
- ログに `send_keys: gj` / `send_keys: gk` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。Godot の CodeEdit API (get_caret_wrap_index, get_line_wrapped_text) を使用してローカル処理。エディタ設定 `text_editor/appearance/lines/word_wrap` を Boundary に設定する必要あり

---

### LP-T3: gg コマンド（ファイル先頭へ移動）
**状態**: Pass

**テスト手順**:
1. 長いファイル（100行以上）を開く
2. `50G` で50行目に移動
3. `gg` を押す
4. カーソルがファイル先頭（1行目）に移動することを確認
5. ビューポートも先頭にスクロールすることを確認

**期待結果**: ファイル先頭に移動する

**Neovim同期確認**:
- ログに `send_keys: gg` が表示される
- Neovimのカーソルも1行目に移動

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。`_ =>` フォールバックで `g{key}` として送信される

---

### LP-T4: g$ / g0 / g^ コマンド（表示行の行末/行頭）
**状態**: Pass

**テスト手順**:
1. 折り返しがある長い行にカーソルを置く
2. `g0` を押す
3. カーソルが表示行の先頭に移動することを確認
4. `g$` を押す
5. カーソルが表示行の末尾に移動することを確認
6. `g^` を押す
7. カーソルが表示行の最初の非空白文字に移動することを確認

**期待結果**: 表示行内で行頭/行末に移動する

**Neovim同期確認**:
- ログに `send_keys: g0` / `send_keys: g$` / `send_keys: g^` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。Godot の CodeEdit API を使用してローカル処理。0/$^ハンドラに last_key!="g" チェックを追加

---

### LP-T5: f{char} / F{char} コマンド（文字検索）
**状態**: Pass

**テスト手順**:
1. 以下のような行にカーソルを置く:
   ```
   func calculate_total(items, price):
   ```
2. 行頭にカーソルを置く
3. `fc` を押す
4. カーソルが`calculate`の`c`に移動することを確認
5. `fl` を押す
6. カーソルが`calculate`の`l`に移動することを確認
7. `Ft` を押す
8. カーソルが`calculate`の`t`に移動することを確認（後方検索）

**期待結果**: 行内で指定文字に移動する

**Neovim同期確認**:
- ログに `send_keys: fc` / `send_keys: fl` / `send_keys: Ft` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T6: t{char} / T{char} コマンド（till検索）
**状態**: Pass

**テスト手順**:
1. 以下のような行にカーソルを置く:
   ```
   func calculate_total(items, price):
   ```
2. 行頭にカーソルを置く
3. `t(` を押す
4. カーソルが`(`の1つ前の`l`に移動することを確認
5. `T_` を押す
6. カーソルが`_`の1つ後の`t`に移動することを確認（後方till）

**期待結果**: 指定文字の手前/後に移動する

**Neovim同期確認**:
- ログに `send_keys: t(` / `send_keys: T_` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T7: ; / , コマンド（検索繰り返し）
**状態**: Pass

**テスト手順**:
1. 以下のような行にカーソルを置く:
   ```
   aaa bbb ccc ddd eee
   ```
2. 行頭にカーソルを置く
3. `fb` を押す（最初の`b`へ移動）
4. `;` を押す
5. 次の`b`に移動することを確認
6. `;` を押す
7. さらに次の`b`（`bbb`の3つ目）に移動することを確認
8. `,` を押す
9. 前の`b`に戻ることを確認

**期待結果**: 最後のf/F/t/T検索を繰り返す

**Neovim同期確認**:
- ログに `send_keys: ;` / `send_keys: ,` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T8: % コマンド（対応括弧へジャンプ）
**状態**: テスト済み

**テスト手順**:
1. 以下のようなコードがある行にカーソルを置く:
   ```
   if (condition && (nested)):
   ```
2. 最初の`(`にカーソルを置く
3. `%` を押す
4. カーソルが対応する`)`に移動することを確認
5. もう一度 `%` を押す
6. カーソルが元の`(`に戻ることを確認
7. `{`と`}`でも同様にテスト
8. `[`と`]`でも同様にテスト

**期待結果**: 対応する括弧に移動する

**Neovim同期確認**:
- ログに `send_keys: %` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T9: [{ / ]} コマンド（ブロック開始/終了へジャンプ）
**状態**: Pass

**テスト手順**:
1. 以下のような関数の中にカーソルを置く:
   ```gdscript
   func test():
       if condition:
           # cursor here
           pass
       pass
   ```
2. コメント行にカーソルを置く
3. `[{` を押す
4. カーソルが`if`行の`:`に移動することを確認（GDScriptでは`{`がないため動作が異なる可能性）
5. `]}` を押す
6. カーソルが対応するブロック終了位置に移動することを確認

**補足**: GDScriptは`{}`を使わないため、Cスタイルの`{}`がある場合のテストも行う:
1. `.json`や`.cfg`ファイルを開く
2. `{`の内部にカーソルを置く
3. `[{` で開始`{`に移動
4. `]}` で終了`}`に移動
5. `Ctrl+O` で元の位置に戻る
6. `Ctrl+I` で再度ジャンプ先に移動

**期待結果**: 囲んでいるブロックの開始/終了に移動し、Ctrl+O/Iでジャンプリストが機能する

**Neovim同期確認**:
- ログに `send_keys: [{` / `send_keys: ]}` が表示される
- ログに `send_keys: <C-o>` / `send_keys: <C-i>` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 修正・テスト通過。根本原因: SHIFTキーイベントでunicode==0→char::from_u32(0)がSome('\0')を返し、[コマンドハンドラのSome(_)ケースでlast_keyがクリアされていた。修正: Some('\0')をNoneと同じ扱いに変更。Ctrl+O/IもNeovimに送信するように変更し、Neovimのジャンプリストを使用

---

### LP-T10: [( / ]) コマンド（括弧開始/終了へジャンプ）
**状態**: Pass

**テスト手順**:
1. 以下のようなコードの内部にカーソルを置く:
   ```
   result = calculate(first_arg, second_arg, third_arg)
   ```
2. `second_arg`にカーソルを置く
3. `[(` を押す
4. カーソルが`(`に移動することを確認
5. `])` を押す
6. カーソルが`)`に移動することを確認

**期待結果**: 囲んでいる括弧の開始/終了に移動する

**Neovim同期確認**:
- ログに `send_keys: [(` / `send_keys: ])` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T11: [m / ]m コマンド（メソッドへジャンプ）
**状態**: 既知の制限

**テスト手順**:
1. 複数の関数があるGDScriptファイルを開く:
   ```gdscript
   func first():
       pass

   func second():
       pass

   func third():
       pass
   ```
2. `second`関数の中にカーソルを置く
3. `[m` を押す
4. カーソルが`first`関数の定義行に移動することを確認
5. `]m` を押す
6. カーソルが`second`関数の定義行に移動することを確認
7. もう一度 `]m` を押す
8. カーソルが`third`関数の定義行に移動することを確認

**期待結果**: 前/次のメソッド定義に移動する

**Neovim同期確認**:
- ログに `send_keys: [m` / `send_keys: ]m` が表示される

**テスト結果**:
- [ ] Pass
- [x] Fail

**備考**: 2025-01-20 テスト - [m, ]mのどちらもジャンプしない。Neovimの[m/]mはC言語系の`{`で始まるメソッド定義を検索するため、GDScriptの`func`キーワードは認識されない。GDScript用のNeovim設定が必要。既知の制限として保留

---

### LP-T12: gI / gi コマンド（特殊インサートモード）
**状態**: テスト済み

**テスト手順**:
1. インデントがある行にカーソルを置く:
   ```
       indented_line
   ```
2. `gI` を押す
3. カーソルが行の絶対先頭（列0）に移動し、Insert modeになることを確認
4. `Esc` で戻る
5. 別の行で編集を行い、`Esc` で戻る
6. 元の行に戻り `gi` を押す
7. 最後に編集した位置でInsert modeになることを確認

**期待結果**:
- `gI`: 行の絶対先頭でInsert mode
- `gi`: 最後の編集位置でInsert mode

**Neovim同期確認**:
- ログに `send_keys: gI` / `send_keys: gi` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過

---

### LP-T13: gJ コマンド（スペースなしで行結合）
**状態**: Pass

**テスト手順**:
1. 2行のコードを用意:
   ```
   first_part
   second_part
   ```
2. 1行目にカーソルを置く
3. `gJ` を押す
4. 行が `first_partsecond_part`（スペースなし）に結合されることを確認

**期待結果**: スペースを挿入せずに行が結合される

**Neovim同期確認**:
- ログに `send_keys: gJ` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。通常の`J`はスペースを挿入する

---

### LP-T14: gp / gP コマンド（ペースト後カーソル移動）
**状態**: Pass

**テスト手順**:
1. 行をヤンク: `yy`
2. 別の行に移動
3. `gp` を押す
4. 行がペーストされ、カーソルがペーストしたテキストの**後**に移動することを確認
5. `u` でUndo
6. `gP` を押す
7. 行がカーソルの**前**にペーストされ、カーソルがペーストしたテキストの後に移動することを確認

**期待結果**:
- `gp`: 下にペーストし、ペースト後の行にカーソル移動
- `gP`: 上にペーストし、ペースト後の行にカーソル移動

**Neovim同期確認**:
- ログに `send_keys: gp` / `send_keys: gP` が表示される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 再テスト通過。ログで `send_keys: gp` と `Applying nvim change` を確認。`:reg` コマンドが空を表示する問題は別issue（ローカルレジスタではなくNeovimレジスタを使用しているため）

---

### LP-T15: マクロ記録テスト
**状態**: Pass

**テスト手順**:
1. ファイルを開く
2. `qa` でマクロ記録開始
3. 以下のコマンドを実行:
   - `ge` (単語末尾へ)
   - `fc` (文字検索)
   - `;` (検索繰り返し)
   - `%` (対応括弧)
4. `q` でマクロ記録終了
5. 別の位置にカーソルを移動
6. `@a` でマクロを実行
7. 記録したコマンドが再生されることを確認

**期待結果**: ローカル処理コマンドがマクロに記録され、正しく再生される

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**:
- 2025-01-20 テスト - ローカル処理のジャンプコマンド（f{char}等）はNeovimにキーが送信されないためマクロに記録されない。ログ: `q: Stopped recording macro 'a' (empty)`
- 2025-01-20 修正 - f/F/t/T および ;/,/% をローカルマクロバッファにも記録するよう修正

---

### LP-T16: g-prefix Godot専用コマンド（Neovimに送信しない）
**状態**: Pass

**テスト手順**:
以下のGodot専用コマンドがNeovimに送信されないことを確認:

1. `gx` - URL/ファイルを開く
   - URLを含む行にカーソルを置く
   - `gx` を押す
   - ブラウザまたはファイルが開くことを確認
   - ログに `send_keys: gx` が表示されないことを確認

2. `gf` - ファイルを開く
   - ファイルパス（例: `res://script.gd`）を含む行にカーソルを置く
   - `gf` を押す
   - ファイルが開くことを確認
   - ログに `send_keys: gf` が表示されないことを確認

3. `gd` - 定義へジャンプ（Godot LSP）
   - 関数呼び出しにカーソルを置く
   - `gd` を押す
   - 定義にジャンプすることを確認
   - ログに `send_keys: gd` が表示されないことを確認

4. `gt` / `gT` - タブ切り替え
   - 複数ファイルを開く
   - `gt` / `gT` でタブ切り替え
   - ログに `send_keys: gt` が表示されないことを確認

5. `ga` - 文字情報表示
   - 文字の上にカーソルを置く
   - `ga` を押す
   - 文字コード情報が表示されることを確認
   - ログに `send_keys: ga` が表示されないことを確認

**期待結果**: Godot専用コマンドはNeovimに送信されない

**テスト結果**:
- [x] Pass
- [ ] Fail

**備考**: 2025-01-20 テスト通過。これらはGodot固有の機能を使用するため、Neovimには送信しない

---

## Neovim Backend テスト (NB) - 未検証機能

Neovimバックエンドで動作する可能性が高いが、正式なテストが行われていない機能。

### NB-T1: ( / ) コマンド（文単位移動）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなテキストを用意:
   ```
   First sentence. Second sentence. Third sentence.
   Fourth sentence. Fifth sentence.
   ```
2. 最初の文字にカーソルを置く
3. `)` を押す
4. カーソルが "Second" の先頭に移動することを確認
5. `)` をもう一度押す
6. カーソルが "Third" の先頭に移動することを確認
7. `(` を押す
8. カーソルが "Second" の先頭に戻ることを確認

**期待結果**: 文単位で前後に移動する（`.` `!` `?` で区切られた文）

**Neovim同期確認**:
- ログに `send_keys: )` / `send_keys: (` が表示される

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**:

---

### NB-T2: [[ / ]] コマンド（セクション移動）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなGDScriptを用意:
   ```gdscript
   extends Node

   func first():
       pass

   func second():
       pass

   func third():
       pass
   ```
2. ファイルの先頭にカーソルを置く
3. `]]` を押す
4. カーソルが次の `{` または関数定義に移動することを確認
5. `]]` をもう一度押す
6. さらに次のセクションに移動することを確認
7. `[[` を押す
8. 前のセクションに戻ることを確認

**期待結果**: セクション（`{` で始まる行）単位で移動する

**Neovim同期確認**:
- ログに `send_keys: ]]` / `send_keys: [[` が表示される

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**: GDScriptでは `{` を使わないため、動作が異なる可能性あり

---

### NB-T3: is / as テキストオブジェクト（文）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなテキストを用意:
   ```
   First sentence. Second sentence. Third sentence.
   ```
2. "Second" の中間にカーソルを置く
3. `vis` を押す（visual inner sentence）
4. "Second sentence" が選択されることを確認（ピリオドは含まない）
5. `Escape` で選択解除
6. 同じ位置で `vas` を押す（visual around sentence）
7. "Second sentence. " が選択されることを確認（後ろのスペースを含む）

**期待結果**:
- `is`: 文の内容のみ選択
- `as`: 文と後ろのスペースを含めて選択

**Neovim同期確認**:
- ログに適切なキーが送信される

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**:

---

### NB-T4: ip / ap テキストオブジェクト（段落）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなテキストを用意:
   ```
   First paragraph line 1.
   First paragraph line 2.

   Second paragraph line 1.
   Second paragraph line 2.

   Third paragraph.
   ```
2. "Second paragraph" の行にカーソルを置く
3. `vip` を押す（visual inner paragraph）
4. 空行を除く段落の行が選択されることを確認
5. `Escape` で選択解除
6. 同じ位置で `vap` を押す（visual around paragraph）
7. 段落と前後の空行を含めて選択されることを確認

**期待結果**:
- `ip`: 段落の内容のみ選択（空行を除く）
- `ap`: 段落と周囲の空行を含めて選択

**Neovim同期確認**:
- ログに適切なキーが送信される

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**:

---

### NB-T5: it / at テキストオブジェクト（タグ）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなXML/HTMLテキストを用意:
   ```
   <div>
       <span>Hello World</span>
   </div>
   ```
2. "Hello World" の中にカーソルを置く
3. `vit` を押す（visual inner tag）
4. "Hello World" が選択されることを確認
5. `Escape` で選択解除
6. 同じ位置で `vat` を押す（visual around tag）
7. `<span>Hello World</span>` 全体が選択されることを確認

**期待結果**:
- `it`: タグの内容のみ選択
- `at`: タグ全体を選択

**Neovim同期確認**:
- ログに適切なキーが送信される

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**: GDScriptでは通常使用しないが、XMLやシェーダーファイルで有用

---

### NB-T6: :1,10d コマンド（行範囲削除）
**状態**: 未テスト

**テスト手順**:
1. 20行以上のファイルを開く
2. `:1,5d` を入力してEnter
3. 1〜5行目が削除されることを確認
4. `u` でUndo
5. `:10,15d` を入力してEnter
6. 10〜15行目が削除されることを確認

**期待結果**: 指定した行範囲が削除される

**Neovim同期確認**:
- ログにコマンドが送信される
- バッファ同期が行われる

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**:

---

### NB-T7: :.,$s/old/new/g コマンド（行範囲置換）
**状態**: 未テスト

**テスト手順**:
1. 以下のようなテキストを用意（10行以上）:
   ```
   line with foo
   another foo line
   foo here too
   more foo
   last foo
   ```
2. 3行目にカーソルを置く
3. `:.,$s/foo/bar/g` を入力してEnter
4. 3行目から最終行までの "foo" が "bar" に置換されることを確認
5. 1〜2行目の "foo" は変更されていないことを確認
6. `u` でUndo
7. `:1,.s/foo/bar/g` を入力してEnter
8. 1行目からカーソル行までの "foo" が "bar" に置換されることを確認

**期待結果**:
- `:.,$`: カーソル行から最終行まで
- `:1,.`: 1行目からカーソル行まで

**Neovim同期確認**:
- ログにコマンドが送信される
- バッファ同期が行われる

**テスト結果**:
- [ ] Pass
- [ ] Fail

**備考**:

---

## ローカル処理テスト 実行履歴

| 日付 | バージョン/ブランチ | 実行者 | 結果 | 備考 |
|------|-------------------|--------|------|------|
| - | - | - | - | - |

---
